name: Build and Package Windows Installer

on: [push, pull_request]

env:
  # Configuration Variables (Change these to match your project)
  QT_VERSION: '6.10.1'
  QT_ARCH: 'win64_msvc2019_64'
  QT_IFW_VERSION: '4.10.0'
  BUILD_TYPE: 'Release'
  
  # Project Specifics
  APP_EXECUTABLE: 'counter_app.exe'
  PACKAGE_DOMAIN: 'com.pocqtquick'
  QML_SOURCE_DIR: 'source/ui' # Where your .qml files live in the source
  
jobs:
  build-installer:
    runs-on: windows-2022
    
    # Defaults to Bash to handle paths consistently
    defaults:
      run:
        shell: bash

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # 1. Setup MSVC Environment (Critical for CMake finding the right compiler)
      - name: Setup MSVC
        uses: ilammy/msvc-dev-cmd@v1

      # 2. Install Qt (Using the Action is cleaner than manual download)
      - name: Install Qt
        uses: jurplel/install-qt-action@v3
        with:
          version: ${{ env.QT_VERSION }}
          arch: ${{ env.QT_ARCH }}
          aqtinstall-version: '>=3.1.0'

      # 3. Setup Qt Installer Framework (Using the Action puts binarycreator in PATH automatically)
      - name: Setup Qt Installer Framework
        uses: jmarrec/setup-qtifw@v1
        with:
          qtifw-version: ${{ env.QT_IFW_VERSION }}

      # 4. Configure and Build
      - name: Build Application
        run: |
          mkdir build
          cd build
          cmake .. -G "Visual Studio 17 2022" -A x64 -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }}
          cmake --build . --config ${{ env.BUILD_TYPE }}

      # 5. Run Unit Tests (From your second snippet - highly recommended)
      - name: Run Unit Tests
        run: |
          cd build
          # CTest is standard for CMake projects
          ctest -C ${{ env.BUILD_TYPE }} --output-on-failure

      # 6. Stage Files for Installer
      - name: Prepare Packaging Directory
        run: |
          # Define the target directory variable for cleaner script
          TARGET_DIR="installer/packages/${{ env.PACKAGE_DOMAIN }}/data"
          
          # Create directory structure
          mkdir -p "$TARGET_DIR"
          
          # Copy the compiled EXE to the package data folder
          # Note: Adjust the source path if your CMakeLists puts the exe elsewhere
          cp build/${{ env.BUILD_TYPE }}/${{ env.APP_EXECUTABLE }} "$TARGET_DIR/"

      # 7. Run Windeployqt
      - name: Deploy Qt Dependencies
        run: |
          TARGET_EXE="installer/packages/${{ env.PACKAGE_DOMAIN }}/data/${{ env.APP_EXECUTABLE }}"
          
          # Combined flags from both inputs:
          # --compiler-runtime: includes vcruntime140.dll (Crucial!)
          # --no-translations: saves space if you don't need Qt's own translations
          # --no-opengl-sw: saves space if you don't need software rendering fallback
          
          windeployqt --release --compiler-runtime --no-translations --no-opengl-sw --qmldir ${{ env.QML_SOURCE_DIR }} "$TARGET_EXE"

      # 8. Create Installer
      - name: Generate Installer Binary
        run: |
          cd installer
          
          # binarycreator is already in PATH thanks to the setup-qtifw action
          binarycreator --offline-installer "Windows_Installer.exe" -c config/config.xml -p packages/

      # 9. Upload Artifact
      - name: Upload Installer
        uses: actions/upload-artifact@v4
        with:
          name: Windows-Installer
          path: installer/Windows_Installer.exe