name: pocqtquick-deploy-prod

# TRIGGER: Manual Run Only
on:
  workflow_dispatch:
    inputs:
      bump_type:
        description: 'Version Bump Type'
        required: true
        default: 'Patch'
        type: choice
        options:
          - Patch
          - Minor
          - Major

env:
  QT_VERSION: '6.10.1'
  QT_ARCH: 'win64_msvc2022_64'
  APP_EXECUTABLE: 'counter_app.exe'
  PACKAGE_DOMAIN: 'com.pocqtquick'
  QML_SOURCE_DIR: 'source/ui'

jobs:
  # ==============================================================================
  # JOB 1: PRE-FLIGHT & CONTEXT
  # ==============================================================================
  pre-flight-check:
    runs-on: ubuntu-latest
    outputs:
      new_tag: ${{ steps.calc_version.outputs.new_tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 1. Check for Pending PRs
      - name: Check for Pending PRs (Release -> Main)
        if: github.ref_name == 'release'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          OPEN_PRS=$(gh pr list --base main --head release --state open --json number --jq 'length')
          if [ "$OPEN_PRS" -gt 0 ]; then
            echo "::error::Deployment Failed: An open PR from 'release' to 'main' exists."
            exit 1
          fi

      # 2. Calculate New Version
      - name: Calculate New Version
        id: calc_version
        run: |
          git fetch --tags
          LATEST_TAG=$(git tag --list 'v*.*.*' --sort=-v:refname | head -n 1)
          if [ -z "$LATEST_TAG" ]; then LATEST_TAG="v0.0.0"; fi
          
          BUMP_TYPE="${{ inputs.bump_type }}"
          VERSION=${LATEST_TAG#v}
          IFS='.' read -r -a parts <<< "$VERSION"
          MAJOR=${parts[0]}; MINOR=${parts[1]}; PATCH=${parts[2]}

          case "$BUMP_TYPE" in
            "Major") MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
            "Minor") MINOR=$((MINOR + 1)); PATCH=0 ;;
            "Patch") PATCH=$((PATCH + 1)) ;;
          esac
          
          NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT

      # 3. Create Job Summary
      - name: Generate Summary
        run: |
          echo "### ðŸš€ Deployment Context" >> $GITHUB_STEP_SUMMARY
          echo "| Setting | Value |" >> $GITHUB_STEP_SUMMARY
          echo "| :--- | :--- |" >> $GITHUB_STEP_SUMMARY
          echo "| **Branch** | ${{ github.ref_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Bump Type** | ${{ inputs.bump_type }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Target Version** | **${{ steps.calc_version.outputs.new_tag }}** |" >> $GITHUB_STEP_SUMMARY

  # ==============================================================================
  # JOB 2: VALIDATION & BUILD
  # Calls the workflow that builds and uploads 'compiled-app'
  # ==============================================================================
  call-validation:
    needs: pre-flight-check
    uses: ./.github/workflows/pocqtquick-validate.yaml

  # ==============================================================================
  # JOB 3: PACKAGE
  # Downloads artifact from validation, creates Installer
  # ==============================================================================
  package:
    needs: [call-validation, pre-flight-check]
    runs-on: windows-2022
    defaults:
      run:
        shell: pwsh
    env:
      VERSION_TAG: ${{ needs.pre-flight-check.outputs.new_tag }}
      INSTALLER_NAME: "pocqtquick-${{ needs.pre-flight-check.outputs.new_tag }}-Windows-x64.exe"
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Qt (IFW)
        uses: jurplel/install-qt-action@v3
        with:
          version: ${{ env.QT_VERSION }}
          arch: ${{ env.QT_ARCH }}
          tools: 'tools_ifw'

      # 
      # 1. Download the artifact produced by 'call-validation'
      - name: Download Binaries from Validation
        uses: actions/download-artifact@v4
        with:
          name: compiled-app  # MATCHES NAME IN VALIDATE YAML
          path: staging

      # 2. Locate the Exe (Since 'compiled-app' contains the whole 'build/' folder)
      - name: Locate and Move Executable
        run: |
          # Find the .exe recursively inside the staging folder
          $exeFile = Get-ChildItem -Path "staging" -Filter $env:APP_EXECUTABLE -Recurse | Select-Object -First 1
          
          if (-not $exeFile) {
             Write-Error "Could not find '$env:APP_EXECUTABLE' inside the downloaded artifact!"
             exit 1
          }
          
          Write-Host "Found executable at: $($exeFile.FullName)"
          
          # Move it to a clean "deploy" folder to simplify windeployqt
          New-Item -ItemType Directory -Force -Path "deploy"
          Move-Item -Path $exeFile.FullName -Destination "deploy\$env:APP_EXECUTABLE"

      - name: Run Windeployqt
        run: |
          $exePath = "deploy\$env:APP_EXECUTABLE"
          windeployqt --release --compiler-runtime --no-translations --no-opengl-sw --qmldir $env:QML_SOURCE_DIR $exePath
          Remove-Item "deploy\*.obj", "deploy\*.cpp", "deploy\*.h" -ErrorAction SilentlyContinue

      - name: Build Installer (IFW)
        run: |
          $targetDir = "installer\packages\$env:PACKAGE_DOMAIN\data"
          New-Item -ItemType Directory -Force -Path $targetDir
          
          # Copy the deployed files (dlls + exe) to IFW data
          Copy-Item -Path "deploy\*" -Destination $targetDir -Recurse

          $binCreator = Get-ChildItem -Path "..\Qt\Tools\QtInstallerFramework\*\bin\binarycreator.exe" | Select-Object -First 1 -ExpandProperty FullName
          
          cd installer
          & $binCreator -c config\config.xml -p packages\ $env:INSTALLER_NAME
          
          echo "INSTALLER_PATH=installer\$env:INSTALLER_NAME" >> $env:GITHUB_ENV

      - name: Upload Installer Artifact
        uses: actions/upload-artifact@v4
        with:
          name: installer-package
          path: ${{ env.INSTALLER_PATH }}

  # ==============================================================================
  # JOB 4: PRODUCTION DEPLOYMENT (Manual Gate)
  # ==============================================================================
  deploy-release:
    needs: [package, pre-flight-check]
    runs-on: ubuntu-latest
    environment: production
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      
      - name: Download Installer
        uses: actions/download-artifact@v4
        with:
          name: installer-package
          path: dist

      - name: Publish GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ needs.pre-flight-check.outputs.new_tag }}
        run: |
          gh release create $TAG \
            dist/*.exe \
            --title "$TAG" \
            --notes "Production deployment initiated manually from **${{ github.ref_name }}**." \
            --latest

  # ==============================================================================
  # JOB 5: SYNC
  # ==============================================================================
  create-sync-pr:
    needs: [deploy-release, pre-flight-check]
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Create Sync PR
        if: github.ref_name == 'release'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ needs.pre-flight-check.outputs.new_tag }}
        run: |
          gh pr create \
            --base main \
            --head release \
            --title "chore(release): Sync $TAG to main" \
            --body "Automated PR created after production deployment of **$TAG**."

      - name: Log Sync Skip
        if: github.ref_name == 'main'
        run: |
          echo "::notice title=Sync Skipped::Current branch is 'main'. No back-sync PR is required."