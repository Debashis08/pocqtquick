name: pocqtquick-github-tag-and-release

# Triggers only when a PR to 'main' is closed
on:
  pull_request:
    types: [closed] # Run when a PR is closed
    branches:
      - 'main'      # Only when the PR's target branch is 'main'

# Permissions required for the tag/release job
permissions:
  contents: write      # To create/push tags AND create releases
  pull-requests: read  # To read the PR body

jobs:
  create-tag-and-release:
    # This job only runs if:
    # 1. The PR was actually merged (implicit from 'needs', but good to be explicit).
    # 2. The PR was from a branch named exactly 'release'.
    if: github.event.pull_request.merged == true && github.event.pull_request.head.ref == 'release'
    runs-on: ubuntu-latest

    steps:
      # Step 1: Check out the code on the 'main' branch
      # fetch-depth: 0 is crucial to get all tags and history
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: 'main'
          fetch-depth: 0 

      # Step 2: Configure Git with bot credentials
      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      # Step 3: Parse the PR body to find the version bump type
      - name: Determine Version Bump
        id: version_bump
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          if echo "$PR_BODY" | grep -q '\[x\] Major'; then
            echo "bump_type=major" >> $GITHUB_OUTPUT
          elif echo "$PR_BODY" | grep -q '\[x\] Minor'; then
            echo "bump_type=minor" >> $GITHUB_OUTPUT
          elif echo "$PR_BODY" | grep -q '\[x\] Patch'; then
            echo "bump_type=patch" >> $GITHUB_OUTPUT
          else
            echo "No version bump type selected in PR body. ([x] Major, [x] Minor, or [x] Patch)."
            exit 1
          fi

      # Step 4: Get the latest tag
      - name: Get latest tag
        id: last_tag
        run: |
          # Fetch all tags from remote just in case
          git fetch --tags
          
          # Find the latest tag matching vX.Y.Z format, sort by version, get the highest
          LATEST_TAG=$(git tag --list 'v*.*.*' --sort=-v:refname | head -n 1)
          
          if [ -z "$LATEST_TAG" ]; then
            echo "No previous vX.Y.Z tag found. Starting from v0.0.0."
            LATEST_TAG="v0.0.0"
          fi
          
          echo "Last tag: $LATEST_TAG"
          echo "last_tag=$LATEST_TAG" >> $GITHUB_OUTPUT

      # Step 5: Calculate the new tag based on the bump type
      - name: Calculate new tag
        id: new_tag
        run: |
          BUMP_TYPE=${{ steps.version_bump.outputs.bump_type }}
          LAST_TAG=${{ steps.last_tag.outputs.last_tag }}
          
          # Strip 'v' prefix
          VERSION=${LAST_TAG#v}
          
          # Split into parts
          IFS='.' read -r -a parts <<< "$VERSION"
          MAJOR=${parts[0]}
          MINOR=${parts[1]}
          PATCH=${parts[2]}
          
          # Increment based on bump type
          case "$BUMP_TYPE" in
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "patch")
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "New tag will be: $NEW_TAG"

      # Step 6: Create and push the new tag
      - name: Create and push new tag
        env:
          PAT: ${{ secrets.POCQTQUICK_PAT_RELEASE_TOKEN }}
        run: |
          NEW_TAG=${{ steps.new_tag.outputs.new_tag }}
          MERGE_COMMIT_SHA=${{ github.event.pull_request.merge_commit_sha }}
          
          echo "Tagging commit $MERGE_COMMIT_SHA as $NEW_TAG"
          git tag $NEW_TAG $MERGE_COMMIT_SHA
          git remote set-url origin https://x-access-token:${PAT}@github.com/${{ github.repository }}.git
          git push origin $NEW_TAG

      # Step 7: Extract Release Summary from PR Body
      - name: Extract Release Summary
        id: extract_summary
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          # Use an awk "state machine" to extract text between the two markers.
          # We use "<<<" (a "here string") to safely pass the multiline $PR_BODY to awk.
          # We must escape the '*' characters with '\' for the regex.
          
          # 1. /\*\*Release Summary\*\*/{f=1; next} : When we see the START marker, set flag 'f' to 1 and skip to the next line.
          # 2. /\*\*Version Bump Type\*\*/{f=0}      : When we see the END marker, set flag 'f' to 0.
          # 3. f                                 : If flag 'f' is 1 (true), print the current line.
          SUMMARY=$(awk '/\*\*Release Summary\*\*/{f=1; next} /\*\*Version Bump Type\*\*/{f=0} f' <<< "$PR_BODY")

          # Use multiline string syntax for GITHUB_OUTPUT
          echo "summary<<EOF" >> $GITHUB_OUTPUT
          echo "$SUMMARY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Step 8: Create GitHub Release
      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NEW_TAG: ${{ steps.new_tag.outputs.new_tag }}
          SUMMARY: ${{ steps.extract_summary.outputs.summary }}
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          # Check if summary is empty, and provide a default
          if [ -z "$SUMMARY" ]; then
            echo "Release summary was empty. Using PR title as notes."
            RELEASE_NOTES="$PR_TITLE"
          else
            RELEASE_NOTES="$SUMMARY"
          fi
          
          # Create the release using the GitHub CLI
          # --latest: Marks this as the latest official release
          # --title: Set to just the tag name as requested
          gh release create $NEW_TAG \
            --title "$NEW_TAG" \
            --notes "$RELEASE_NOTES" \
            --target ${{ github.event.pull_request.merge_commit_sha }} \
            --latest