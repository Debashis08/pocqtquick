name: deploy-prod

on:
  workflow_dispatch:
    inputs:
      bump_type:
        description: 'Version Bump Type (Ignored if on main)'
        required: true
        default: 'Patch'
        type: choice
        options:
          - Patch
          - Minor
          - Major

env:
  QT_VERSION: '6.10.1'
  QT_ARCH: 'win64_msvc2022_64'
  APP_EXECUTABLE: 'appCounterApp.exe'
  PACKAGE_DOMAIN: 'com.pocqtquick' 
  QML_SOURCE_DIR: 'src/ui'

jobs:
  # job 1: production deployment validation & versioning
  prod-deployment-validation:
    runs-on: ubuntu-latest
    outputs:
      new_tag: ${{ steps.calc_version.outputs.new_tag }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 1. Validate Branch Permissions
      - name: Validate Branch Permissions
        run: |
          CURRENT_BRANCH="${{ github.ref_name }}"
          if [[ "$CURRENT_BRANCH" != "main" && ! "$CURRENT_BRANCH" == release/* && ! "$CURRENT_BRANCH" == hotfix/* ]]; then
            echo "::error::Restricted: You cannot deploy from branch '$CURRENT_BRANCH'. Only 'main', 'release/*', or 'hotfix/*' allowed."
            exit 1
          fi

      # 2. Check for Pending PRs
      - name: Check for Pending PRs to main
        if: startsWith(github.ref_name, 'release/') || startsWith(github.ref_name, 'hotfix/')
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          EXISTING_PRS=$(gh pr list --base main --state open --json headRefName --jq '.[].headRefName')
          CONFLICTING_BRANCHES=$(echo "$EXISTING_PRS" | grep -E '^(release|hotfix)/' || true)

          if [ -n "$CONFLICTING_BRANCHES" ]; then
            echo "::error::Deployment Locked: Pending PRs found: $CONFLICTING_BRANCHES"
            exit 1
          fi

      # 3. Calculate New Version
      - name: Calculate New Version
        id: calc_version
        run: |
          git fetch --tags
          LATEST_TAG=$(git tag --list 'v*.*.*' --sort=-v:refname | head -n 1)
          if [ -z "$LATEST_TAG" ]; then LATEST_TAG="v0.0.0"; fi
          
          if [ "${{ github.ref_name }}" == "main" ]; then
             BUMP_TYPE="Patch"
          else
             BUMP_TYPE="${{ inputs.bump_type }}"
          fi

          VERSION=${LATEST_TAG#v}
          IFS='.' read -r -a parts <<< "$VERSION"
          MAJOR=${parts[0]}; MINOR=${parts[1]}; PATCH=${parts[2]}

          case "$BUMP_TYPE" in
            "Major") MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
            "Minor") MINOR=$((MINOR + 1)); PATCH=0 ;;
            "Patch") PATCH=$((PATCH + 1)) ;;
          esac
          
          NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT

      - name: Generate Summary
        run: |
          # Create a clickable link for the commit
          COMMIT_LINK="${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}"
          
          # Use heredoc for cleaner multi-line writing
          cat <<EOF >> $GITHUB_STEP_SUMMARY
          #### Deployment Context
          **Environment**: \`production\`
          **User**: @${{ github.actor }}
          **Branch**: [${{ github.ref_name }}](${{ github.server_url }}/${{ github.repository }}/tree/${{ github.ref_name }})
          **Commit**: [${{ github.sha }}]($COMMIT_LINK)
          **Bump Type**: \`${{ inputs.bump_type }}\`
          **New Version**: \`${{ steps.calc_version.outputs.new_tag }}\`
          **Time stamp**: $(date -u "+%Y-%m-%d %H:%M:%S UTC")
          EOF

  # job 2: validation (Builds the app)
  validation:
    needs: prod-deployment-validation
    uses: ./.github/workflows/validate.yaml
    with:
      target_env: 'production'
    secrets: inherit

  # job 3: package windows application (Inno Setup)
  package-windows-application:
    needs: [validation, prod-deployment-validation]
    runs-on: windows-2022
    defaults:
      run:
        shell: pwsh
    env:
      VERSION_TAG: ${{ needs.prod-deployment-validation.outputs.new_tag }}
      # We just name the installer artifact "installer-package" internally
      
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # 1. Install Dependencies
      - name: Install Qt
        uses: jurplel/install-qt-action@v3
        with:
          version: ${{ env.QT_VERSION }}
          arch: ${{ env.QT_ARCH }}
          aqtversion: '>=3.1.6'
          modules: 'qt5compat'

      - name: Install Inno Setup
        run: choco install innosetup --no-progress

      # 2. Download Build Artifact
      - name: Download Build Artifact
        uses: actions/download-artifact@v4
        with:
          name: compiled-app
          path: download_temp

      # 3. Prepare Staging Area (Windeployqt)
      - name: Run Windeployqt
        run: |
          $targetDir = "dist"
          New-Item -ItemType Directory -Force -Path $targetDir

          # Move Exe to dist
          $exePath = Get-ChildItem -Path "download_temp" -Filter $env:APP_EXECUTABLE -Recurse | Select-Object -First 1 -ExpandProperty FullName
          if (-not $exePath) { Write-Error "Exe not found"; exit 1 }
          Move-Item -Path $exePath -Destination $targetDir

          # Run Windeployqt
          $stagedExe = "$targetDir\$env:APP_EXECUTABLE"
          windeployqt --release --compiler-runtime --no-translations --no-opengl-sw --qmldir $env:QML_SOURCE_DIR $stagedExe
          
          # Clean junk files
          Remove-Item "$targetDir\*.obj", "$targetDir\*.cpp", "$targetDir\*.h", "$targetDir\*.cmake" -ErrorAction SilentlyContinue

      # 4. Build Installer with Inno Setup
      - name: Build Installer (Inno Setup)
        run: |
          # Clean version string (remove 'v') for Windows metadata
          $versionClean = "${{ env.VERSION_TAG }}".Replace("v", "")
          $installerName = "pocqtquick-${{ env.VERSION_TAG }}-Windows-x64-Setup"
          
          # Get Absolute Path to the dist folder (Critical for Inno)
          $absSourceDir = (Resolve-Path "dist").Path
          Write-Host "Inno Source Dir: $absSourceDir"

          # Run Inno Setup Compiler
          # We pass /DMyAppVersion so the Windows Installer shows the correct version
          & "C:\Program Files (x86)\Inno Setup 6\ISCC.exe" `
            "/DMyAppSourceDir=$absSourceDir" `
            "/DMyAppExeName=$env:APP_EXECUTABLE" `
            "/DMyOutputFilename=$installerName" `
            "/DMyAppVersion=$versionClean" `
            installer/windows-setup.iss
          
          # Check result
          if (Test-Path "installer/Output/$installerName.exe") {
             Write-Host "Installer created successfully."
          } else {
             Write-Error "Installer generation failed."
             exit 1
          }

      - name: Upload Installer Exe
        uses: actions/upload-artifact@v4
        with:
          name: installer-package
          path: installer/Output/*.exe
          retention-days: 10

  # job 4: produce github tag and release
  create-github-tag-and-release:
    needs: [package-windows-application, prod-deployment-validation]
    runs-on: ubuntu-latest
    environment: production
    permissions:
      contents: write
      pull-requests: read # REQUIRED: Allows release-drafter to read PR labels
    steps:
      - uses: actions/checkout@v4
      
      - name: Download Installer
        uses: actions/download-artifact@v4
        with:
          name: installer-package
          path: dist-release

      # 1. Create the Release with Auto-Generated Notes
      - name: Create Release
        id: create_release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        uses: release-drafter/release-drafter@v6
        with:
          config-name: release.yaml # Ensures it uses your custom config
          tag: ${{ needs.prod-deployment-validation.outputs.new_tag }}
          name: "${{ needs.prod-deployment-validation.outputs.new_tag }}"
          version: ${{ needs.prod-deployment-validation.outputs.new_tag }}
          publish: true

      # 2. Upload the Installer Exe to the new Release
      - name: Upload Installer to release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ needs.prod-deployment-validation.outputs.new_tag }}
        run: |
          # Uploads all .exe files found in dist-release
          gh release upload $TAG dist-release/*.exe --clobber

  # job 5: create sync pull request to main
  create-sync-pull-request:
    needs: [create-github-tag-and-release, prod-deployment-validation]
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Create Sync pull request to main
        if: startsWith(github.ref_name, 'release/') || startsWith(github.ref_name, 'hotfix/')
        env:
          GH_TOKEN: ${{ secrets.POCQTQUICK_AUTO_PR }}
          TAG: ${{ needs.prod-deployment-validation.outputs.new_tag }}
        run: |
          gh pr create \
            --base main \
            --head "${{ github.ref_name }}" \
            --title "chore(${{ github.ref_name }}): Sync $TAG to main" \
            --body "Automated PR created after production deployment of **$TAG**."

      - name: Log Sync Skip
        if: github.ref_name == 'main'
        run: echo "::notice::Sync skipped for main branch."